#  Common TLS configuration for TLS-based EAP types
#  ------------------------------------------------
#
#  See raddb/certs/README for additional comments
#  on certificates.
#
#  If OpenSSL was not found at the time the server was
#  built, the "tls", "ttls", and "peap" sections will
#  be ignored.
#
#  If you do not currently have certificates signed by
#  a trusted CA you may use the 'snakeoil' certificates.
#  Included with the server in raddb/certs.
#
#  If these certificates have not been auto-generated:
#    cd raddb/certs
#    make
#
#  These test certificates SHOULD NOT be used in a normal
#  deployment.  They are created only to make it easier
#  to install the server, and to perform some simple
#  tests with EAP-TLS, TTLS, or PEAP.
#
#  Note that you should NOT use a globally known CA here!
#  e.g. using a Verisign cert as a "known CA" means that
#  ANYONE who has a certificate signed by them can
#  authenticate via EAP-TLS!  This is likely not what you want.
#
tls-config tls-common {
  private_key_password = whatever
    private_key_file = ${certdir}/server.pem

#  If Private key & Certificate are located in
#  the same file, then private_key_file &
#  certificate_file must contain the same file
#  name.
#
#  If ca_file (below) is not used, then the
#  certificate_file below SHOULD also include all of
#  the intermediate CA certificates used to sign the
#  server certificate, but NOT the root CA.
#
#  Including the ROOT CA certificate is not useful and
#  merely inflates the exchanged data volume during
#  the TLS negotiation.
#
#  This file should contain the server certificate,
#  followed by intermediate certificates, in order.
#  i.e. If we have a server certificate signed by CA1,
#  which is signed by CA2, which is signed by a root
#  CA, then the "certificate_file" should contain
#  server.pem, followed by CA1.pem, followed by
#  CA2.pem.
#
#  When using "ca_file" or "ca_dir", the
#  "certificate_file" should contain only
#  "server.pem".  And then you may (or may not) need
#  to set "auto_chain", depending on your version of
#  OpenSSL.
#
#  In short, SSL / TLS certificates are complex.
#  There are many versions of software, each of which
#  behave slightly differently.  It is impossible to
#  give advice which will work everywhere.  Instead,
#  we give general guidelines.
#
    certificate_file = ${certdir}/server.pem

#  Trusted Root CA list
#
#  This file can contain multiple CA certificates.
#  ALL of the CA's in this list will be trusted to
#  issue client certificates for authentication.
#
#  In general, you should use self-signed
#  certificates for 802.1x (EAP) authentication.
#  In that case, this CA file should contain
#  *one* CA certificate.
#
    ca_file = ${cadir}/ca.pem

#  OpenSSL will automatically create certificate chains,
#  unless we tell it to not do that.  The problem is that
#  it sometimes gets the chains right from a certificate
#  signature view, but wrong from the clients view.
#
#  When setting "auto_chain = no", the server certificate
#  file MUST include the full certificate chain.
#
#	auto_chain = yes

#  If OpenSSL supports TLS-PSK, then we can use a
#  fixed PSK identity and (hex) password.  As of
#  3.0.18, these can be used at the same time as the
#  certificate configuration, but only for TLS 1.0
#  through 1.2.
#
#  If PSK and certificates are configured at the same
#  time for TLS 1.3, then the server will warn you,
#  and will disable TLS 1.3, as it will not work.
#
#  The work around is to have two modules (or for
#  RadSec, two listen sections).  One will have PSK
#  configured, and the other will have certificates
#  configured.
#
#	psk_identity = "test"
#	psk_hexphrase = "036363823"

#  Dynamic queries for the PSK.  If TLS-PSK is used,
#  and psk_query is set, then you MUST NOT use
#  psk_identity or psk_hexphrase.
#
#  Instead, use a dynamic expansion similar to the one
#  below.  It keys off of TLS-PSK-Identity.  It should
#  return a of string no more than 512 hex characters.
#  That string will be converted to binary, and will
#  be used as the dynamic PSK hexphrase.
#
#  Note that this query is just an example.  You will
#  need to customize it for your installation.
#
#	psk_query = "%{sql:select hex(key) from psk_keys where keyid = '%{TLS-PSK-Identity}'}"

#  For DH cipher suites to work, you have to
#  run OpenSSL to create the DH file first:
#
#    openssl dhparam -out certs/dh 2048
#
    dh_file = ${certdir}/dh

#  If your system doesn't have /dev/urandom,
#  you will need to create this file, and
#  periodically change its contents.
#
#  For security reasons, FreeRADIUS doesn't
#  write to files in its configuration
#  directory.
#
#	random_file = /dev/urandom

#  This can never exceed the size of a RADIUS
#  packet (4096 bytes), and is preferably half
#  that, to accommodate other attributes in
#  RADIUS packet.  On most APs the MAX packet
#  length is configured between 1500 - 1600
#  In these cases, fragment size should be
#  1024 or less.
#
#	fragment_size = 1024

#  include_length is a flag which is
#  by default set to yes If set to
#  yes, Total Length of the message is
#  included in EVERY packet we send.
#  If set to no, Total Length of the
#  message is included ONLY in the
#  First packet of a fragment series.
#
#	include_length = yes


#  Check the Certificate Revocation List
#
#  1) Copy CA certificates and CRLs to same directory.
#  2) Execute 'c_rehash <CA certs&CRLs Directory>'.
#     'c_rehash' is OpenSSL's command.
#  3) uncomment the lines below.
#  5) Restart radiusd
#	check_crl = yes

# Check if intermediate CAs have been revoked.
#	check_all_crl = yes

    ca_path = ${cadir}

# Accept an expired Certificate Revocation List
#
#	allow_expired_crl = no

#  If check_cert_issuer is set, the value will
#  be checked against the DN of the issuer in
#  the client certificate.  If the values do not
#  match, the certificate verification will fail,
#  rejecting the user.
#
#  This check can be done more generally by checking
#  the value of the TLS-Client-Cert-Issuer attribute.
#  This check can be done via any mechanism you
#  choose.
#
#	check_cert_issuer = "/C=GB/ST=Berkshire/L=Newbury/O=My Company Ltd"

#  If check_cert_cn is set, the value will
#  be xlat'ed and checked against the CN
#  in the client certificate.  If the values
#  do not match, the certificate verification
#  will fail rejecting the user.
#
#  This check is done only if the previous
#  "check_cert_issuer" is not set, or if
#  the check succeeds.
#
#  In 2.1.10 and later, this check can be done
#  more generally by checking the value of the
#  TLS-Client-Cert-Common-Name attribute.  This check
#  can be done via any mechanism you choose.
#
#	check_cert_cn = %{User-Name}

#  Set this option to specify the allowed
#  TLS cipher suites.  The format is listed
#  in "man 1 ciphers".
#
#  For EAP-FAST, use "ALL:!EXPORT:!eNULL:!SSLv2"
#
  cipher_list = "DEFAULT"

#  If enabled, OpenSSL will use server cipher list
#  (possibly defined by cipher_list option above)
#  for choosing right cipher suite rather than
#  using client-specified list which is OpenSSl default
#  behavior.  Setting this to "yes" means that OpenSSL
#  will choose the servers ciphers, even if they do not
#  best match what the client sends.
#
#  TLS negotiation is usually good, but can be imperfect.
#  This setting allows administrators to "fine tune" it
#  if necessary.
#
    cipher_server_preference = no

#  You can selectively disable TLS versions for
#  compatability with old client devices.
#
#  If your system has OpenSSL 1.1.0 or greater, do NOT
#  use these.  Instead, set tls_min_version and
#  tls_max_version.
#
#	disable_tlsv1_2 = no
    disable_tlsv1_1 = yes
    disable_tlsv1 = yes

#  Set min / max TLS version.  Mainly for Debian
#  "trusty", which disables older versions of TLS, and
#  requires the application to manually enable them.
#
#  If you are running Debian trusty, you should set
#  these options, otherwise older clients will not be
#  able to connect.
#
#  Allowed values are "1.0", "1.1", "1.2", and "1.3".
#
#  Note that the server WILL NOT permit negotiation of
#  TLS 1.3.  The EAP-TLS standards for TLS 1.3 are NOT
#  finished.  It is therefore impossible for the server
#  to negotiate EAP-TLS correctly with TLS 1.3.
#
#  The values must be in quotes.
#
    tls_min_version = "1.2"
    tls_max_version = "1.2"

#  Elliptical cryptography configuration
#
#  Only for OpenSSL >= 0.9.8.f
#
    ecdh_curve = "prime256v1"

#  Session resumption / fast reauthentication
#  cache.
#
#  The cache contains the following information:
#
#   session Id - unique identifier, managed by SSL
#   User-Name  - from the Access-Accept
#   Stripped-User-Name - from the Access-Request
#   Cached-Session-Policy - from the Access-Accept
#
#  See also the "store" subsection below for
#  additional attributes which can be cached.
#
#  The "Cached-Session-Policy" is the name of a
#  policy which should be applied to the cached
#  session.  This policy can be used to assign
#  VLANs, IP addresses, etc.  It serves as a useful
#  way to re-apply the policy from the original
#  Access-Accept to the subsequent Access-Accept
#  for the cached session.
#
#  On session resumption, these attributes are
#  copied from the cache, and placed into the
#  reply list.
#
#  You probably also want "use_tunneled_reply = yes"
#  when using fast session resumption.
#
#  You can check if a session has been resumed by
#  looking for the existence of the EAP-Session-Resumed
#  attribute.  Note that this attribute will *only*
#  exist in the "post-auth" section.
#
#  CAVEATS: The cache is stored and reloaded BEFORE
#  the "post-auth" section is run.  This limitation
#  makes caching more difficult than it should be.  In
#  practice, it means that the first authentication
#  session must set the reply attributes before the
#  post-auth section is run.
#
#  When the session is resumed, the attributes are
#  restored and placed into the session-state list.
#
    cache {
#  Enable it.  The default is "no". Deleting the entire "cache"
#  subsection also disables caching.
#
#  As of version 3.0.14, the session cache requires the use
#  of the "name" and "persist_dir" configuration items, below.
#
#  The internal OpenSSL session cache has been permanently
#  disabled.
#
#  You can disallow resumption for a particular user by adding the
#  following attribute to the control item list:
#
#    Allow-Session-Resumption = No
#
#  If "enable = no" below, you CANNOT enable resumption for just one
#  user by setting the above attribute to "yes".
#
      enable = no

#  Lifetime of the cached entries, in hours. The sessions will be
#  deleted/invalidated after this time.
#
        lifetime = 24 # hours

#  Internal "name" of the session cache. Used to
#  distinguish which TLS context sessions belong to.
#
#  The server will generate a random value if unset.
#  This will change across server restart so you MUST
#  set the "name" if you want to persist sessions (see
#  below).
#
#	name = "EAP module"

#  Simple directory-based storage of sessions.
#  Two files per session will be written, the SSL
#  state and the cached VPs. This will persist session
#  across server restarts.
#
#  The default directory is ${logdir}, for historical
#  reasons.  You should ${db_dir} instead.  And check
#  the value of db_dir in the main radiusd.conf file.
#  It should not point to ${raddb}
#
#  The server will need write perms, and the directory
#  should be secured from anyone else. You might want
#  a script to remove old files from here periodically:
#
#    find ${logdir}/tlscache -mtime +2 -exec rm -f {} \;
#
#  This feature REQUIRES "name" option be set above.
#
#	persist_dir = "${logdir}/tlscache"

#
#  As of 3.0.20, it is possible to partially
#  control which attributes exist in the
#  session cache.  This subsection lists
#  attributes which are taken from the reply,
#  and saved to the on-disk cache.  When the
#  session is resumed, these attributes are
#  added to the "session-state" list.  The
#  default configuration will then take care
#  of copying them to the reply.
#
        store {
          Tunnel-Private-Group-Id
        }
    }

#  As of version 2.1.10, client certificates can be
#  validated via an external command.  This allows
#  dynamic CRLs or OCSP to be used.
#
#  This configuration is commented out in the
#  default configuration.  Uncomment it, and configure
#  the correct paths below to enable it.
#
#  If OCSP checking is enabled, and the OCSP checks fail,
#  the verify section is not run.
#
#  If OCSP checking is disabled, the verify section is
#  run on successful certificate validation.
#
  verify {
#  If the OCSP checks succeed, the verify section
#  is run to allow additional checks.
#
#  If you want to skip verify on OCSP success,
#  uncomment this configuration item, and set it
#  to "yes".
#
#	skip_if_ocsp_ok = no

#  A temporary directory where the client
#  certificates are stored.  This directory
#  MUST be owned by the UID of the server,
#  and MUST not be accessible by any other
#  users.  When the server starts, it will do
#  "chmod go-rwx" on the directory, for
#  security reasons.  The directory MUST
#  exist when the server starts.
#
#  You should also delete all of the files
#  in the directory when the server starts.
#
#	tmpdir = /tmp/radiusd

#  The command used to verify the client cert.
#  We recommend using the OpenSSL command-line
#  tool.
#
#  The ${..ca_path} text is a reference to
#  the ca_path variable defined above.
#
#  The %{TLS-Client-Cert-Filename} is the name
#  of the temporary file containing the cert
#  in PEM format.  This file is automatically
#  deleted by the server when the command
#  returns.
#
#	client = "/path/to/openssl verify -CApath ${..ca_path} %{TLS-Client-Cert-Filename}"
  }

#  OCSP Configuration
#
#  Certificates can be verified against an OCSP
#  Responder. This makes it possible to immediately
#  revoke certificates without the distribution of
#  new Certificate Revocation Lists (CRLs).
#
  ocsp {
#  Enable it.  The default is "no".
#  Deleting the entire "ocsp" subsection
#  also disables ocsp checking
#
    enable = yes

#  The OCSP Responder URL can be automatically
#  extracted from the certificate in question.
#  To override the OCSP Responder URL set
#  "override_cert_url = yes".
#
      override_cert_url = no

#  If the OCSP Responder address is not extracted from
#  the certificate, the URL can be defined here.
#
      url = "http://127.0.0.1/ocsp/"

# If the OCSP Responder can not cope with nonce
# in the request, then it can be disabled here.
#
# For security reasons, disabling this option
# is not recommended as nonce protects against
# replay attacks.
#
# Note that Microsoft AD Certificate Services OCSP
# Responder does not enable nonce by default. It is
# more secure to enable nonce on the responder than
# to disable it in the query here.
# See http://technet.microsoft.com/en-us/library/cc770413%28WS.10%29.aspx
#
#	use_nonce = yes

# Number of seconds before giving up waiting
# for OCSP response. 0 uses system default.
#
#	timeout = 0

# Normally an error in querying the OCSP
# responder (no response from server, server did
# not understand the request, etc) will result in
# a validation failure.
#
# To treat these errors as 'soft' failures and
# still accept the certificate, enable this
# option.
#
# Warning: this may enable clients with revoked
# certificates to connect if the OCSP responder
# is not available. Use with caution.
#
#	softfail = no
  }
}
